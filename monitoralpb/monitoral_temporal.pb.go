// Code generated by protoc-gen-go_temporal. DO NOT EDIT.

package monitoralpb

import (
	context "context"
	fmt "fmt"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	reflect "reflect"
)

// Constants used as workflow, activity, query, and signal names.
const (
	HostWorkflowName               = "monitoral.v1.Monitoral.HostWorkflow"
	SystemWorkflowName             = "monitoral.v1.Monitoral.SystemWorkflow"
	HostRunActivityName            = "monitoral.v1.Monitoral.HostRunActivity"
	HostUpdateConfigActivityName   = "monitoral.v1.Monitoral.HostUpdateConfigActivity"
	HostCollectActivityName        = "monitoral.v1.Monitoral.HostCollectActivity"
	SystemUpdateConfigActivityName = "monitoral.v1.Monitoral.SystemUpdateConfigActivity"
	SystemGetNotificationsName     = "monitoral.v1.Monitoral.SystemGetNotifications"
	SystemGetConfigName            = "monitoral.v1.Monitoral.SystemGetConfig"
	HostRunName                    = "monitoral.v1.Monitoral.HostRun"
	HostUpdateConfigName           = "monitoral.v1.Monitoral.HostUpdateConfig"
	HostDoneName                   = "monitoral.v1.Monitoral.HostDone"
	SystemUpdateConfigName         = "monitoral.v1.Monitoral.SystemUpdateConfig"
	SystemUpdateNotificationsName  = "monitoral.v1.Monitoral.SystemUpdateNotifications"
	HostCollectSignalName          = "monitoral.v1.Monitoral.HostCollect"
	HostCollectResponseName        = HostCollectSignalName + "-response"
)

type Client interface {

	// HostWorkflow runs on the system task queue and maintains a long-running
	// activity on the host. This will contain the following search attributes:
	// * "monitoral-host" - Hostname
	// * "monitoral-tags" - String array of tags
	ExecuteHostWorkflow(ctx context.Context, opts *client.StartWorkflowOptions, req *HostWorkflowRequest) (HostWorkflowRun, error)

	// GetHostWorkflow returns an existing run started by ExecuteHostWorkflow.
	GetHostWorkflow(ctx context.Context, workflowID, runID string) (HostWorkflowRun, error)

	// SystemWorkflow is the single workflow for managing config and
	// notifications.
	ExecuteSystemWorkflow(ctx context.Context, opts *client.StartWorkflowOptions, req *SystemWorkflowRequest) (SystemWorkflowRun, error)

	// GetSystemWorkflow returns an existing run started by ExecuteSystemWorkflow.
	GetSystemWorkflow(ctx context.Context, workflowID, runID string) (SystemWorkflowRun, error)

	// SystemGetNotifications returns notifications.
	SystemGetNotifications(ctx context.Context, workflowID, runID string, req *SystemGetNotificationsRequest) (*SystemGetNotificationsResponse, error)

	// SystemGetConfig returns the current system config.
	SystemGetConfig(ctx context.Context, workflowID, runID string, req *SystemGetConfigRequest) (*SystemGetConfigResponse, error)

	// HostRun is sent as signal-with-start to HostWorkflow to start or restart
	// the long-running activity on the host with the given task queue. If it is a
	// restart, the existing activity is expected to be cancelled if
	// running.
	HostRun(ctx context.Context, workflowID, runID string, req *HostRunRequest) error

	// HostUpdateConfig requests the workflow to update the given configurations.
	// This is usually called from an activity from the system workflow to update
	// config.
	//
	// There is a known race condition where a config can be updated on the system
	// workflow while a host is just getting started and therefore the host may
	// not by in the list to update. It is encumbent upon the host workflow
	// starter to wait a reasonable amount of time after the workflow is started
	// and check that the config didn't change or if it did, re-deliver the
	// signal.
	HostUpdateConfig(ctx context.Context, workflowID, runID string, req *HostUpdateConfigRequest) error

	// Signal sent when the host is known to be done. This is sent with a
	// signal-with-start so that it can make a new successfully closed workflow
	// on top of a failed one if necessary.
	HostDone(ctx context.Context, workflowID, runID string, req *HostDoneRequest) error

	// SystemUpdateConfig is the signal to update the entire config.
	SystemUpdateConfig(ctx context.Context, workflowID, runID string, req *SystemUpdateConfigRequest) error

	// SystemUpdateNotifications creates/updates notifications.
	SystemUpdateNotifications(ctx context.Context, workflowID, runID string, req *SystemUpdateNotificationsRequest) error

	// HostCollect manually collects latest metrics for the host.
	HostCollect(ctx context.Context, workflowID, runID string, req *HostCollectRequest) (*HostCollectResponse, error)
}

// ClientOptions are used for NewClient.
type ClientOptions struct {
	// Required client.
	Client client.Client
	// Handler that must be present for client calls to succeed.
	CallResponseHandler CallResponseHandler
}

// CallResponseHandler handles activity responses.
type CallResponseHandler interface {
	// TaskQueue returns the task queue for response activities.
	TaskQueue() string

	// PrepareCall creates a new ID and channels to receive response/error.
	// Each channel only has a buffer of one and are never closed and only one is ever sent to.
	// If context is closed, the context error is returned on error channel.
	PrepareCall(ctx context.Context) (id string, chOk <-chan interface{}, chErr <-chan error)

	// AddResponseType adds an activity for the given type and ID field.
	// Does not error if activity name already exists for the same params.
	AddResponseType(activityName string, typ reflect.Type, idField string) error
}

type clientImpl struct {
	client              client.Client
	callResponseHandler CallResponseHandler
}

// NewClient creates a new Client.
func NewClient(opts ClientOptions) Client {
	if opts.Client == nil {
		panic("missing client")
	}
	c := &clientImpl{client: opts.Client, callResponseHandler: opts.CallResponseHandler}
	if opts.CallResponseHandler != nil {
		if err := opts.CallResponseHandler.AddResponseType(HostCollectResponseName, reflect.TypeOf((*HostCollectResponse)(nil)), "Id"); err != nil {
			panic(err)
		}
	}
	return c
}

func (c *clientImpl) ExecuteHostWorkflow(ctx context.Context, opts *client.StartWorkflowOptions, req *HostWorkflowRequest) (HostWorkflowRun, error) {
	if opts == nil {
		opts = &client.StartWorkflowOptions{}
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, HostWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &hostWorkflowRun{c, run}, nil
}

func (c *clientImpl) GetHostWorkflow(ctx context.Context, workflowID, runID string) (HostWorkflowRun, error) {
	return &hostWorkflowRun{c, c.client.GetWorkflow(ctx, workflowID, runID)}, nil
}

func (c *clientImpl) ExecuteSystemWorkflow(ctx context.Context, opts *client.StartWorkflowOptions, req *SystemWorkflowRequest) (SystemWorkflowRun, error) {
	if opts == nil {
		opts = &client.StartWorkflowOptions{}
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SystemWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &systemWorkflowRun{c, run}, nil
}

func (c *clientImpl) GetSystemWorkflow(ctx context.Context, workflowID, runID string) (SystemWorkflowRun, error) {
	return &systemWorkflowRun{c, c.client.GetWorkflow(ctx, workflowID, runID)}, nil
}

func (c *clientImpl) SystemGetNotifications(ctx context.Context, workflowID, runID string, req *SystemGetNotificationsRequest) (*SystemGetNotificationsResponse, error) {
	var resp SystemGetNotificationsResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SystemGetNotificationsName, req); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *clientImpl) SystemGetConfig(ctx context.Context, workflowID, runID string, req *SystemGetConfigRequest) (*SystemGetConfigResponse, error) {
	var resp SystemGetConfigResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SystemGetConfigName, req); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *clientImpl) HostRun(ctx context.Context, workflowID, runID string, req *HostRunRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, HostRunName, req)
}

func (c *clientImpl) HostUpdateConfig(ctx context.Context, workflowID, runID string, req *HostUpdateConfigRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, HostUpdateConfigName, req)
}

func (c *clientImpl) HostDone(ctx context.Context, workflowID, runID string, req *HostDoneRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, HostDoneName, req)
}

func (c *clientImpl) SystemUpdateConfig(ctx context.Context, workflowID, runID string, req *SystemUpdateConfigRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SystemUpdateConfigName, req)
}

func (c *clientImpl) SystemUpdateNotifications(ctx context.Context, workflowID, runID string, req *SystemUpdateNotificationsRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SystemUpdateNotificationsName, req)
}

func (c *clientImpl) HostCollect(ctx context.Context, workflowID, runID string, req *HostCollectRequest) (*HostCollectResponse, error) {
	if c.callResponseHandler == nil {
		return nil, fmt.Errorf("missing response handler")
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	id, chOk, chErr := c.callResponseHandler.PrepareCall(ctx)
	req.Id = id
	req.ResponseTaskQueue = c.callResponseHandler.TaskQueue()
	if err := c.client.SignalWorkflow(ctx, workflowID, runID, HostCollectSignalName, req); err != nil {
		return nil, err
	}
	select {
	case resp := <-chOk:
		return resp.(*HostCollectResponse), nil
	case err := <-chErr:
		return nil, err
	}
}

// HostWorkflowRun represents an execution of HostWorkflow.
type HostWorkflowRun interface {
	// ID is the workflow ID.
	ID() string

	// RunID is the workflow run ID.
	RunID() string

	// Get returns the completed workflow value, waiting if necessary.
	Get(ctx context.Context) error

	// HostRun is sent as signal-with-start to HostWorkflow to start or restart
	// the long-running activity on the host with the given task queue. If it is a
	// restart, the existing activity is expected to be cancelled if
	// running.
	HostRun(ctx context.Context, req *HostRunRequest) error

	// HostUpdateConfig requests the workflow to update the given configurations.
	// This is usually called from an activity from the system workflow to update
	// config.
	//
	// There is a known race condition where a config can be updated on the system
	// workflow while a host is just getting started and therefore the host may
	// not by in the list to update. It is encumbent upon the host workflow
	// starter to wait a reasonable amount of time after the workflow is started
	// and check that the config didn't change or if it did, re-deliver the
	// signal.
	HostUpdateConfig(ctx context.Context, req *HostUpdateConfigRequest) error

	// Signal sent when the host is known to be done. This is sent with a
	// signal-with-start so that it can make a new successfully closed workflow
	// on top of a failed one if necessary.
	HostDone(ctx context.Context, req *HostDoneRequest) error

	// HostCollect manually collects latest metrics for the host.
	HostCollect(ctx context.Context, req *HostCollectRequest) (*HostCollectResponse, error)
}

type hostWorkflowRun struct {
	client *clientImpl
	run    client.WorkflowRun
}

func (r *hostWorkflowRun) ID() string { return r.run.GetID() }

func (r *hostWorkflowRun) RunID() string { return r.run.GetRunID() }

func (r *hostWorkflowRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

func (r *hostWorkflowRun) HostRun(ctx context.Context, req *HostRunRequest) error {
	return r.client.HostRun(ctx, r.ID(), "", req)
}

func (r *hostWorkflowRun) HostUpdateConfig(ctx context.Context, req *HostUpdateConfigRequest) error {
	return r.client.HostUpdateConfig(ctx, r.ID(), "", req)
}

func (r *hostWorkflowRun) HostDone(ctx context.Context, req *HostDoneRequest) error {
	return r.client.HostDone(ctx, r.ID(), "", req)
}

func (r *hostWorkflowRun) HostCollect(ctx context.Context, req *HostCollectRequest) (*HostCollectResponse, error) {
	return r.client.HostCollect(ctx, r.ID(), "", req)
}

// SystemWorkflowRun represents an execution of SystemWorkflow.
type SystemWorkflowRun interface {
	// ID is the workflow ID.
	ID() string

	// RunID is the workflow run ID.
	RunID() string

	// Get returns the completed workflow value, waiting if necessary.
	Get(ctx context.Context) error

	// SystemGetNotifications returns notifications.
	SystemGetNotifications(ctx context.Context, req *SystemGetNotificationsRequest) (*SystemGetNotificationsResponse, error)

	// SystemGetConfig returns the current system config.
	SystemGetConfig(ctx context.Context, req *SystemGetConfigRequest) (*SystemGetConfigResponse, error)

	// SystemUpdateConfig is the signal to update the entire config.
	SystemUpdateConfig(ctx context.Context, req *SystemUpdateConfigRequest) error

	// SystemUpdateNotifications creates/updates notifications.
	SystemUpdateNotifications(ctx context.Context, req *SystemUpdateNotificationsRequest) error
}

type systemWorkflowRun struct {
	client *clientImpl
	run    client.WorkflowRun
}

func (r *systemWorkflowRun) ID() string { return r.run.GetID() }

func (r *systemWorkflowRun) RunID() string { return r.run.GetRunID() }

func (r *systemWorkflowRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

func (r *systemWorkflowRun) SystemGetNotifications(ctx context.Context, req *SystemGetNotificationsRequest) (*SystemGetNotificationsResponse, error) {
	return r.client.SystemGetNotifications(ctx, r.ID(), "", req)
}

func (r *systemWorkflowRun) SystemGetConfig(ctx context.Context, req *SystemGetConfigRequest) (*SystemGetConfigResponse, error) {
	return r.client.SystemGetConfig(ctx, r.ID(), "", req)
}

func (r *systemWorkflowRun) SystemUpdateConfig(ctx context.Context, req *SystemUpdateConfigRequest) error {
	return r.client.SystemUpdateConfig(ctx, r.ID(), "", req)
}

func (r *systemWorkflowRun) SystemUpdateNotifications(ctx context.Context, req *SystemUpdateNotificationsRequest) error {
	return r.client.SystemUpdateNotifications(ctx, r.ID(), "", req)
}

// HostWorkflow runs on the system task queue and maintains a long-running
// activity on the host. This will contain the following search attributes:
// * "monitoral-host" - Hostname
// * "monitoral-tags" - String array of tags
type HostWorkflowImpl interface {
	Run(workflow.Context) error
}

// HostWorkflowInput is input provided to HostWorkflowImpl.Run.
type HostWorkflowInput struct {
	Req              *HostWorkflowRequest
	HostRun          HostRun
	HostUpdateConfig HostUpdateConfig
	HostDone         HostDone
	HostCollect      HostCollect
}

type hostWorkflowWorker struct {
	newImpl func(workflow.Context, *HostWorkflowInput) (HostWorkflowImpl, error)
}

func (w hostWorkflowWorker) HostWorkflow(ctx workflow.Context, req *HostWorkflowRequest) error {
	in := &HostWorkflowInput{Req: req}
	in.HostRun.Channel = workflow.GetSignalChannel(ctx, HostRunName)
	in.HostUpdateConfig.Channel = workflow.GetSignalChannel(ctx, HostUpdateConfigName)
	in.HostDone.Channel = workflow.GetSignalChannel(ctx, HostDoneName)
	in.HostCollect.Channel = workflow.GetSignalChannel(ctx, HostCollectSignalName)
	impl, err := w.newImpl(ctx, in)
	if err != nil {
		return err
	}
	return impl.Run(ctx)
}

// BuildHostWorkflow returns a function for the given impl.
func BuildHostWorkflow(newImpl func(workflow.Context, *HostWorkflowInput) (HostWorkflowImpl, error)) func(ctx workflow.Context, req *HostWorkflowRequest) error {
	return hostWorkflowWorker{newImpl}.HostWorkflow
}

// RegisterHostWorkflow registers a workflow with the given impl.
func RegisterHostWorkflow(r worker.WorkflowRegistry, newImpl func(workflow.Context, *HostWorkflowInput) (HostWorkflowImpl, error)) {
	r.RegisterWorkflowWithOptions(BuildHostWorkflow(newImpl), workflow.RegisterOptions{Name: HostWorkflowName})
}

// SystemWorkflow is the single workflow for managing config and
// notifications.
type SystemWorkflowImpl interface {
	Run(workflow.Context) error

	SystemGetNotifications(*SystemGetNotificationsRequest) (*SystemGetNotificationsResponse, error)

	SystemGetConfig(*SystemGetConfigRequest) (*SystemGetConfigResponse, error)
}

// SystemWorkflowInput is input provided to SystemWorkflowImpl.Run.
type SystemWorkflowInput struct {
	Req                       *SystemWorkflowRequest
	SystemUpdateConfig        SystemUpdateConfig
	SystemUpdateNotifications SystemUpdateNotifications
}

type systemWorkflowWorker struct {
	newImpl func(workflow.Context, *SystemWorkflowInput) (SystemWorkflowImpl, error)
}

func (w systemWorkflowWorker) SystemWorkflow(ctx workflow.Context, req *SystemWorkflowRequest) error {
	in := &SystemWorkflowInput{Req: req}
	in.SystemUpdateConfig.Channel = workflow.GetSignalChannel(ctx, SystemUpdateConfigName)
	in.SystemUpdateNotifications.Channel = workflow.GetSignalChannel(ctx, SystemUpdateNotificationsName)
	impl, err := w.newImpl(ctx, in)
	if err != nil {
		return err
	}
	if err := workflow.SetQueryHandler(ctx, SystemGetNotificationsName, impl.SystemGetNotifications); err != nil {
		return err
	}
	if err := workflow.SetQueryHandler(ctx, SystemGetConfigName, impl.SystemGetConfig); err != nil {
		return err
	}
	return impl.Run(ctx)
}

// BuildSystemWorkflow returns a function for the given impl.
func BuildSystemWorkflow(newImpl func(workflow.Context, *SystemWorkflowInput) (SystemWorkflowImpl, error)) func(ctx workflow.Context, req *SystemWorkflowRequest) error {
	return systemWorkflowWorker{newImpl}.SystemWorkflow
}

// RegisterSystemWorkflow registers a workflow with the given impl.
func RegisterSystemWorkflow(r worker.WorkflowRegistry, newImpl func(workflow.Context, *SystemWorkflowInput) (SystemWorkflowImpl, error)) {
	r.RegisterWorkflowWithOptions(BuildSystemWorkflow(newImpl), workflow.RegisterOptions{Name: SystemWorkflowName})
}

// HostRun is sent as signal-with-start to HostWorkflow to start or restart
// the long-running activity on the host with the given task queue. If it is a
// restart, the existing activity is expected to be cancelled if
// running.
type HostRun struct{ Channel workflow.ReceiveChannel }

// Receive blocks until signal is received.
func (s HostRun) Receive(ctx workflow.Context) *HostRunRequest {
	var resp HostRunRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s HostRun) ReceiveAsync() *HostRunRequest {
	var resp HostRunRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil.
func (s HostRun) Select(sel workflow.Selector, fn func(*HostRunRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// HostUpdateConfig requests the workflow to update the given configurations.
// This is usually called from an activity from the system workflow to update
// config.
//
// There is a known race condition where a config can be updated on the system
// workflow while a host is just getting started and therefore the host may
// not by in the list to update. It is encumbent upon the host workflow
// starter to wait a reasonable amount of time after the workflow is started
// and check that the config didn't change or if it did, re-deliver the
// signal.
type HostUpdateConfig struct{ Channel workflow.ReceiveChannel }

// Receive blocks until signal is received.
func (s HostUpdateConfig) Receive(ctx workflow.Context) *HostUpdateConfigRequest {
	var resp HostUpdateConfigRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s HostUpdateConfig) ReceiveAsync() *HostUpdateConfigRequest {
	var resp HostUpdateConfigRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil.
func (s HostUpdateConfig) Select(sel workflow.Selector, fn func(*HostUpdateConfigRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// Signal sent when the host is known to be done. This is sent with a
// signal-with-start so that it can make a new successfully closed workflow
// on top of a failed one if necessary.
type HostDone struct{ Channel workflow.ReceiveChannel }

// Receive blocks until signal is received.
func (s HostDone) Receive(ctx workflow.Context) *HostDoneRequest {
	var resp HostDoneRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s HostDone) ReceiveAsync() *HostDoneRequest {
	var resp HostDoneRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil.
func (s HostDone) Select(sel workflow.Selector, fn func(*HostDoneRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SystemUpdateConfig is the signal to update the entire config.
type SystemUpdateConfig struct{ Channel workflow.ReceiveChannel }

// Receive blocks until signal is received.
func (s SystemUpdateConfig) Receive(ctx workflow.Context) *SystemUpdateConfigRequest {
	var resp SystemUpdateConfigRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s SystemUpdateConfig) ReceiveAsync() *SystemUpdateConfigRequest {
	var resp SystemUpdateConfigRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil.
func (s SystemUpdateConfig) Select(sel workflow.Selector, fn func(*SystemUpdateConfigRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SystemUpdateNotifications creates/updates notifications.
type SystemUpdateNotifications struct{ Channel workflow.ReceiveChannel }

// Receive blocks until signal is received.
func (s SystemUpdateNotifications) Receive(ctx workflow.Context) *SystemUpdateNotificationsRequest {
	var resp SystemUpdateNotificationsRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s SystemUpdateNotifications) ReceiveAsync() *SystemUpdateNotificationsRequest {
	var resp SystemUpdateNotificationsRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil.
func (s SystemUpdateNotifications) Select(sel workflow.Selector, fn func(*SystemUpdateNotificationsRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// HostCollect manually collects latest metrics for the host.
type HostCollect struct{ Channel workflow.ReceiveChannel }

// Receive blocks until call is received.
func (s HostCollect) Receive(ctx workflow.Context) *HostCollectRequest {
	var resp HostCollectRequest
	s.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns received signal or nil if none.
func (s HostCollect) ReceiveAsync() *HostCollectRequest {
	var resp HostCollectRequest
	if !s.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when signal received. Callback can be nil
func (s HostCollect) Select(sel workflow.Selector, fn func(*HostCollectRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// Respond sends a response. Activity options not used if request received via
// another workflow. If activity options needed and not present, they are taken
// from the context.
func (s HostCollect) Respond(ctx workflow.Context, opts *workflow.ActivityOptions, req *HostCollectRequest, resp *HostCollectResponse) workflow.Future {
	resp.Id = req.Id
	if req.ResponseWorkflowId != "" {
		return workflow.SignalExternalWorkflow(ctx, req.ResponseWorkflowId, "", HostCollectResponseName+"-"+req.Id, resp)
	}
	newOpts := workflow.GetActivityOptions(ctx)
	if opts != nil {
		newOpts = *opts
	}
	newOpts.TaskQueue = req.ResponseTaskQueue
	ctx = workflow.WithActivityOptions(ctx, newOpts)
	return workflow.ExecuteActivity(ctx, HostCollectResponseName, resp)
}

// HostWorkflowChild executes a child workflow.
// If options not present, they are taken from the context.
func HostWorkflowChild(ctx workflow.Context, opts *workflow.ChildWorkflowOptions, req *HostWorkflowRequest) HostWorkflowChildRun {
	if opts == nil {
		ctxOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return HostWorkflowChildRun{workflow.ExecuteChildWorkflow(ctx, HostWorkflowName, req)}
}

// HostWorkflowChildRun is a future for the child workflow.
type HostWorkflowChildRun struct{ Future workflow.ChildWorkflowFuture }

// WaitStart waits for the child workflow to start.
func (r HostWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r HostWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(HostWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// Get returns the completed workflow value, waiting if necessary.
func (r HostWorkflowChildRun) Get(ctx workflow.Context) error {
	return r.Future.Get(ctx, nil)
}

// Select adds this completion to the selector. Callback can be nil.
func (r HostWorkflowChildRun) Select(sel workflow.Selector, fn func(HostWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// HostRun is sent as signal-with-start to HostWorkflow to start or restart
// the long-running activity on the host with the given task queue. If it is a
// restart, the existing activity is expected to be cancelled if
// running.
func (r HostWorkflowChildRun) HostRun(ctx workflow.Context, req *HostRunRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, HostRunName, req)
}

// HostUpdateConfig requests the workflow to update the given configurations.
// This is usually called from an activity from the system workflow to update
// config.
//
// There is a known race condition where a config can be updated on the system
// workflow while a host is just getting started and therefore the host may
// not by in the list to update. It is encumbent upon the host workflow
// starter to wait a reasonable amount of time after the workflow is started
// and check that the config didn't change or if it did, re-deliver the
// signal.
func (r HostWorkflowChildRun) HostUpdateConfig(ctx workflow.Context, req *HostUpdateConfigRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, HostUpdateConfigName, req)
}

// Signal sent when the host is known to be done. This is sent with a
// signal-with-start so that it can make a new successfully closed workflow
// on top of a failed one if necessary.
func (r HostWorkflowChildRun) HostDone(ctx workflow.Context, req *HostDoneRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, HostDoneName, req)
}

// HostCollect manually collects latest metrics for the host.
func (r HostWorkflowChildRun) HostCollect(ctx workflow.Context, req *HostCollectRequest) (HostCollectResponseExternal, error) {
	var resp HostCollectResponseExternal
	if req.Id == "" {
		return resp, fmt.Errorf("missing request ID")
	}
	if req.ResponseTaskQueue != "" {
		return resp, fmt.Errorf("cannot have task queue for child")
	}
	req.ResponseWorkflowId = workflow.GetInfo(ctx).WorkflowExecution.ID
	resp.Channel = workflow.GetSignalChannel(ctx, HostCollectResponseName+"-"+req.Id)
	resp.Future = r.Future.SignalChildWorkflow(ctx, HostCollectSignalName, req)
	return resp, nil
}

// SystemWorkflowChild executes a child workflow.
// If options not present, they are taken from the context.
func SystemWorkflowChild(ctx workflow.Context, opts *workflow.ChildWorkflowOptions, req *SystemWorkflowRequest) SystemWorkflowChildRun {
	if opts == nil {
		ctxOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return SystemWorkflowChildRun{workflow.ExecuteChildWorkflow(ctx, SystemWorkflowName, req)}
}

// SystemWorkflowChildRun is a future for the child workflow.
type SystemWorkflowChildRun struct{ Future workflow.ChildWorkflowFuture }

// WaitStart waits for the child workflow to start.
func (r SystemWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r SystemWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(SystemWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// Get returns the completed workflow value, waiting if necessary.
func (r SystemWorkflowChildRun) Get(ctx workflow.Context) error {
	return r.Future.Get(ctx, nil)
}

// Select adds this completion to the selector. Callback can be nil.
func (r SystemWorkflowChildRun) Select(sel workflow.Selector, fn func(SystemWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SystemUpdateConfig is the signal to update the entire config.
func (r SystemWorkflowChildRun) SystemUpdateConfig(ctx workflow.Context, req *SystemUpdateConfigRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SystemUpdateConfigName, req)
}

// SystemUpdateNotifications creates/updates notifications.
func (r SystemWorkflowChildRun) SystemUpdateNotifications(ctx workflow.Context, req *SystemUpdateNotificationsRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SystemUpdateNotificationsName, req)
}

// HostRun is sent as signal-with-start to HostWorkflow to start or restart
// the long-running activity on the host with the given task queue. If it is a
// restart, the existing activity is expected to be cancelled if
// running.
func HostRunExternal(ctx workflow.Context, workflowID, runID string, req *HostRunRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, HostRunName, req)
}

// HostUpdateConfig requests the workflow to update the given configurations.
// This is usually called from an activity from the system workflow to update
// config.
//
// There is a known race condition where a config can be updated on the system
// workflow while a host is just getting started and therefore the host may
// not by in the list to update. It is encumbent upon the host workflow
// starter to wait a reasonable amount of time after the workflow is started
// and check that the config didn't change or if it did, re-deliver the
// signal.
func HostUpdateConfigExternal(ctx workflow.Context, workflowID, runID string, req *HostUpdateConfigRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, HostUpdateConfigName, req)
}

// Signal sent when the host is known to be done. This is sent with a
// signal-with-start so that it can make a new successfully closed workflow
// on top of a failed one if necessary.
func HostDoneExternal(ctx workflow.Context, workflowID, runID string, req *HostDoneRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, HostDoneName, req)
}

// SystemUpdateConfig is the signal to update the entire config.
func SystemUpdateConfigExternal(ctx workflow.Context, workflowID, runID string, req *SystemUpdateConfigRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SystemUpdateConfigName, req)
}

// SystemUpdateNotifications creates/updates notifications.
func SystemUpdateNotificationsExternal(ctx workflow.Context, workflowID, runID string, req *SystemUpdateNotificationsRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SystemUpdateNotificationsName, req)
}

// HostCollect manually collects latest metrics for the host.
func HostCollectExternal(ctx workflow.Context, workflowID, runID string, req *HostCollectRequest) (HostCollectResponseExternal, error) {
	var resp HostCollectResponseExternal
	if req.Id == "" {
		return resp, fmt.Errorf("missing request ID")
	}
	if req.ResponseTaskQueue != "" {
		return resp, fmt.Errorf("cannot have task queue for child")
	}
	req.ResponseWorkflowId = workflow.GetInfo(ctx).WorkflowExecution.ID
	resp.Channel = workflow.GetSignalChannel(ctx, HostCollectResponseName+"-"+req.Id)
	resp.Future = workflow.SignalExternalWorkflow(ctx, workflowID, runID, HostCollectSignalName, req)
	return resp, nil
}

// HostCollectResponseExternal represents a call response.
type HostCollectResponseExternal struct {
	Future  workflow.Future
	Channel workflow.ReceiveChannel
}

// WaitSent blocks until the request is sent.
func (e HostCollectResponseExternal) WaitSent(ctx workflow.Context) error {
	return e.Future.Get(ctx, nil)
}

// SelectSent adds when a request is sent to the selector. Callback can be nil.
func (e HostCollectResponseExternal) SelectSent(sel workflow.Selector, fn func(HostCollectResponseExternal)) workflow.Selector {
	return sel.AddFuture(e.Future, func(workflow.Future) {
		if fn != nil {
			fn(e)
		}
	})
}

// Receive blocks until response is received.
func (e HostCollectResponseExternal) Receive(ctx workflow.Context) *HostCollectResponse {
	var resp HostCollectResponse
	e.Channel.Receive(ctx, &resp)
	return &resp
}

// ReceiveAsync returns response or nil if none.
func (e HostCollectResponseExternal) ReceiveAsync() *HostCollectResponse {
	var resp HostCollectResponse
	if !e.Channel.ReceiveAsync(&resp) {
		return nil
	}
	return &resp
}

// Select adds the callback to the selector to be invoked when response received. Callback can be nil
func (e HostCollectResponseExternal) Select(sel workflow.Selector, fn func(*HostCollectResponse)) workflow.Selector {
	return sel.AddReceive(e.Channel, func(workflow.ReceiveChannel, bool) {
		req := e.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// ActivitiesImpl is an interface for activity implementations.
type ActivitiesImpl interface {

	// HostRunActivity is the long-running activity on the host. This only returns
	// successfully on cancel and the value can be used to call again to resume
	// where left off.
	HostRunActivity(context.Context, *HostRunRequest) (*HostRunRequest, error)

	// HostUpdateConfigActivity is the update activity triggered by the signal.
	HostUpdateConfigActivity(context.Context, *HostUpdateConfigRequest) error

	// HostCollectActivity is the collect activity triggered by the call.
	HostCollectActivity(context.Context, *HostCollectRequest) (*HostCollectResponse, error)

	// SystemUpdateConfigActivity is the update activity triggered by the signal.
	SystemUpdateConfigActivity(context.Context, *SystemUpdateConfigRequest) error
}

// RegisterActivities registers all activities in the interface.
func RegisterActivities(r worker.ActivityRegistry, a ActivitiesImpl) {
	RegisterHostRunActivity(r, a.HostRunActivity)
	RegisterHostUpdateConfigActivity(r, a.HostUpdateConfigActivity)
	RegisterHostCollectActivity(r, a.HostCollectActivity)
	RegisterSystemUpdateConfigActivity(r, a.SystemUpdateConfigActivity)
}

// RegisterHostRunActivity registers the single activity.
func RegisterHostRunActivity(r worker.ActivityRegistry, impl func(context.Context, *HostRunRequest) (*HostRunRequest, error)) {
	r.RegisterActivityWithOptions(impl, activity.RegisterOptions{Name: HostRunActivityName})
}

// HostRunActivity is the long-running activity on the host. This only returns
// successfully on cancel and the value can be used to call again to resume
// where left off.
func HostRunActivity(ctx workflow.Context, opts *workflow.ActivityOptions, req *HostRunRequest) HostRunActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	return HostRunActivityFuture{workflow.ExecuteActivity(ctx, HostRunActivityName, req)}
}

// HostRunActivity is the long-running activity on the host. This only returns
// successfully on cancel and the value can be used to call again to resume
// where left off.
func HostRunActivityLocal(ctx workflow.Context, opts *workflow.LocalActivityOptions, fn func(context.Context, *HostRunRequest) (*HostRunRequest, error), req *HostRunRequest) HostRunActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	return HostRunActivityFuture{workflow.ExecuteLocalActivity(ctx, fn, req)}
}

// HostRunActivityFuture represents completion of the activity.
type HostRunActivityFuture struct{ Future workflow.Future }

// Get waits for completion.
func (f HostRunActivityFuture) Get(ctx workflow.Context) (*HostRunRequest, error) {
	var resp HostRunRequest
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the completion to the selector. Callback can be nil.
func (f HostRunActivityFuture) Select(sel workflow.Selector, fn func(HostRunActivityFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// RegisterHostUpdateConfigActivity registers the single activity.
func RegisterHostUpdateConfigActivity(r worker.ActivityRegistry, impl func(context.Context, *HostUpdateConfigRequest) error) {
	r.RegisterActivityWithOptions(impl, activity.RegisterOptions{Name: HostUpdateConfigActivityName})
}

// HostUpdateConfigActivity is the update activity triggered by the signal.
func HostUpdateConfigActivity(ctx workflow.Context, opts *workflow.ActivityOptions, req *HostUpdateConfigRequest) HostUpdateConfigActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	return HostUpdateConfigActivityFuture{workflow.ExecuteActivity(ctx, HostUpdateConfigActivityName, req)}
}

// HostUpdateConfigActivity is the update activity triggered by the signal.
func HostUpdateConfigActivityLocal(ctx workflow.Context, opts *workflow.LocalActivityOptions, fn func(context.Context, *HostUpdateConfigRequest) error, req *HostUpdateConfigRequest) HostUpdateConfigActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	return HostUpdateConfigActivityFuture{workflow.ExecuteLocalActivity(ctx, fn, req)}
}

// HostUpdateConfigActivityFuture represents completion of the activity.
type HostUpdateConfigActivityFuture struct{ Future workflow.Future }

// Get waits for completion.
func (f HostUpdateConfigActivityFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the completion to the selector. Callback can be nil.
func (f HostUpdateConfigActivityFuture) Select(sel workflow.Selector, fn func(HostUpdateConfigActivityFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// RegisterHostCollectActivity registers the single activity.
func RegisterHostCollectActivity(r worker.ActivityRegistry, impl func(context.Context, *HostCollectRequest) (*HostCollectResponse, error)) {
	r.RegisterActivityWithOptions(impl, activity.RegisterOptions{Name: HostCollectActivityName})
}

// HostCollectActivity is the collect activity triggered by the call.
func HostCollectActivity(ctx workflow.Context, opts *workflow.ActivityOptions, req *HostCollectRequest) HostCollectActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	return HostCollectActivityFuture{workflow.ExecuteActivity(ctx, HostCollectActivityName, req)}
}

// HostCollectActivity is the collect activity triggered by the call.
func HostCollectActivityLocal(ctx workflow.Context, opts *workflow.LocalActivityOptions, fn func(context.Context, *HostCollectRequest) (*HostCollectResponse, error), req *HostCollectRequest) HostCollectActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	return HostCollectActivityFuture{workflow.ExecuteLocalActivity(ctx, fn, req)}
}

// HostCollectActivityFuture represents completion of the activity.
type HostCollectActivityFuture struct{ Future workflow.Future }

// Get waits for completion.
func (f HostCollectActivityFuture) Get(ctx workflow.Context) (*HostCollectResponse, error) {
	var resp HostCollectResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the completion to the selector. Callback can be nil.
func (f HostCollectActivityFuture) Select(sel workflow.Selector, fn func(HostCollectActivityFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// RegisterSystemUpdateConfigActivity registers the single activity.
func RegisterSystemUpdateConfigActivity(r worker.ActivityRegistry, impl func(context.Context, *SystemUpdateConfigRequest) error) {
	r.RegisterActivityWithOptions(impl, activity.RegisterOptions{Name: SystemUpdateConfigActivityName})
}

// SystemUpdateConfigActivity is the update activity triggered by the signal.
func SystemUpdateConfigActivity(ctx workflow.Context, opts *workflow.ActivityOptions, req *SystemUpdateConfigRequest) SystemUpdateConfigActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	return SystemUpdateConfigActivityFuture{workflow.ExecuteActivity(ctx, SystemUpdateConfigActivityName, req)}
}

// SystemUpdateConfigActivity is the update activity triggered by the signal.
func SystemUpdateConfigActivityLocal(ctx workflow.Context, opts *workflow.LocalActivityOptions, fn func(context.Context, *SystemUpdateConfigRequest) error, req *SystemUpdateConfigRequest) SystemUpdateConfigActivityFuture {
	if opts == nil {
		ctxOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &ctxOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	return SystemUpdateConfigActivityFuture{workflow.ExecuteLocalActivity(ctx, fn, req)}
}

// SystemUpdateConfigActivityFuture represents completion of the activity.
type SystemUpdateConfigActivityFuture struct{ Future workflow.Future }

// Get waits for completion.
func (f SystemUpdateConfigActivityFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the completion to the selector. Callback can be nil.
func (f SystemUpdateConfigActivityFuture) Select(sel workflow.Selector, fn func(SystemUpdateConfigActivityFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}
